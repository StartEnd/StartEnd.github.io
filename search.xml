<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python 迭代器]]></title>
    <url>%2Fpython%2F2e39bde6%2F</url>
    <content type="text"><![CDATA[Python 迭代器,生成器在程序设计中，通常会有 loop、iterate、traversal 和 recursion 等概念，他们各自的含义如下：循环（loop），指的是在满足条件的情况下，重复执行同一段代码。比如 Python 中的 while 语句。迭代（iterate），指的是按照某种顺序逐个访问列表中的每一项。比如 Python 中的 for 语句。递归（recursion），指的是一个函数不断调用自身的行为。比如，以编程方式输出著名的斐波纳契数列。遍历（traversal），指的是按照一定的规则访问树形结构中的每个节点，而且每个节点都只访问一次。在其他语言中，for 与 while 都用于循环，而 Python 则没有类似其他语言的 for 循环，只有 while 来实现循环。在 Python 中， for 用来实现迭代，它的结构是 for … in …，其在迭代时会产生迭代器，实际是将可迭代对象转换成迭代器，再重复调用 next() 方法实现的。在了解Python的数据结构时，容器(container)、可迭代对象(iterable)、迭代器(iterator)、生成器(generator)、列表/集合/字典推导式(list,set,dict comprehension)众多概念参杂在一起，难免让初学者一头雾水，我将用一篇文章试图将这些概念以及它们之间的关系捋清楚。容器(container)容器是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个地迭代获取，可以用in, not in关键字判断元素是否包含在容器中。通常这类数据结构把所有的元素存储在内存中（也有一些特例，并不是所有的元素都放在内存，比如迭代器和生成器对象）在Python中，常见的容器对象有：list, deque, ….set, frozensets, ….dict, defaultdict, OrderedDict, Counter, ….tuple, namedtuple, …str容器比较容易理解，因为你就可以把它看作是一个盒子、一栋房子、一个柜子，里面可以塞任何东西。从技术角度来说，当它可以用来询问某个元素是否包含在其中时，那么这个对象就可以认为是一个容器，比如 list，set，tuples都是容器对象：123456&gt;&gt;&gt; assert 1 in [1, 2, 3] # lists&gt;&gt;&gt; s = 'foobar'&gt;&gt;&gt; assert 'b' in s&gt;&gt;&gt; &gt;&gt;&gt; d = &#123;1: 'foo', 2: 'bar', 3: 'qux'&#125;&gt;&gt;&gt; assert 1 in d&gt;&gt;&gt; assert 'foo' not in d # 'foo' 不是dict中的元素尽管绝大多数容器都提供了某种方式来获取其中的每一个元素，但这并不是容器本身提供的能力，而是可迭代对象赋予了容器这种能力，当然并不是所有的容器都是可迭代的，比如：Bloom filter，虽然Bloom filter可以用来检测某个元素是否包含在容器中，但是并不能从容器中获取其中的每一个值，因为Bloom filter压根就没把元素存储在容器中，而是通过一个散列函数映射成一个值保存在数组中。可迭代对象(iterable)刚才说过，很多容器都是可迭代对象，此外还有更多的对象同样也是可迭代对象，比如处于打开状态的files，sockets等等。但凡是可以返回一个迭代器的对象都可称之为可迭代对象，听起来可能有点困惑，没关系，先看一个例子12345678910111213&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; y = iter(x)&gt;&gt;&gt; z = iter(x)&gt;&gt;&gt; next(y)1&gt;&gt;&gt; next(y)2&gt;&gt;&gt; next(z)1&gt;&gt;&gt; type(x)&lt;class 'list'&gt;&gt;&gt;&gt; type(y)&lt;class 'list_iterator'&gt;这里x是一个可迭代对象，可迭代对象和容器一样是一种通俗的叫法，并不是指某种具体的数据类型，list是可迭代对象，dict是可迭代对象，set也是可迭代对象。y和z是两个独立的迭代器，迭代器内部持有一个状态，该状态用于记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。迭代器有一种具体的迭代器类型，比如list_iterator，set_iterator。可迭代对象实现了iter方法，该方法返回一个迭代器对象。当运行代码:123x = [1, 2, 3]for elem in x: ...实际执行情况是:反编译该段代码，你可以看到解释器显示地调用GET_ITER指令，相当于调用iter(x)，FOR_ITER指令就是调用next()方法，不断地获取迭代器中的下一个元素，但是你没法直接从指令中看出来，因为他被解释器优化过了。123456789101112&gt;&gt;&gt; import dis&gt;&gt;&gt; x = [1, 2, 3]&gt;&gt;&gt; dis.dis('for _ in x: pass') 1 0 SETUP_LOOP 12 (to 14) 2 LOAD_NAME 0 (x) 4 GET_ITER &gt;&gt; 6 FOR_ITER 4 (to 12) 8 STORE_NAME 1 (_) 10 JUMP_ABSOLUTE 6 &gt;&gt; 12 POP_BLOCK &gt;&gt; 14 LOAD_CONST 0 (None) 16 RETURN_VALUE可迭代对象具有__iter__ 方法，用于返回一个迭代器，或者定义了 __getitem__ 方法，可以按 index 索引的对象（并且能够在没有值时抛出一个 IndexError 异常），因此，可迭代对象就是能够通过它得到一个迭代器的对象。所以，可迭代对象都可以通过调用内建的 iter() 方法返回一个迭代器。可迭代器对象具有如下的特性：可以 for 循环: for i in iterable；可以按 index 索引的对象，也就是定义了 __getitem__ 方法，比如 list,str;定义了__iter__方法，可以随意返回；可以调用 iter(obj) 的对象，并且返回一个iterator。可以通过isinstance(obj, collections.Iterable)来判断对象是否为可迭代对象。迭代器对象(iterator)迭代器对象是一个含有 next (Python 2) 或者 __next__ (Python 3) 方法的对象。如果需要自定义迭代器，则需要满足如下迭代器协议：定义了__iter__ 方法，但是必须返回自身定义了 next 方法,在 python3.x 是 __next__。用来返回下一个值，并且当没有数据了，抛出 StopIteration可以保持当前的状态可以通过 isinstance(obj, collections.Iterator) 来判断对象是否为迭代器。(用一句来总结就是，一个实现了 __iter__() 方法的对象是可迭代的，一个实现了 next() 方法的对象则是迭代器。那么什么迭代器呢？它是一个带状态的对象，他能在你调用next()方法的时候返回容器中的下一个值，任何实现了__iter__和__next__()（python2中实现next()）方法的对象都是迭代器，__iter__返回迭代器自身，__next__返回容器中的下一个值，如果容器中没有更多元素了，则抛出StopIteration异常，至于它们到底是如何实现的这并不重要。所以，迭代器就是实现了工厂模式的对象，它在你每次你询问要下一个值的时候给你返回。有很多关于迭代器的例子，比如itertools函数返回的都是迭代器对象。生成无限序列：123456&gt;&gt;&gt; from itertools import count&gt;&gt;&gt; counter = count(start=13)&gt;&gt;&gt; next(counter)13&gt;&gt;&gt; next(counter)14从一个有限序列中生成无限序列：12345678910&gt;&gt;&gt; from itertools import cycle&gt;&gt;&gt; colors = cycle(['red', 'white', 'blue'])&gt;&gt;&gt; next(colors)'red'&gt;&gt;&gt; next(colors)'white'&gt;&gt;&gt; next(colors)'blue'&gt;&gt;&gt; next(colors)'red'从无限的序列中生成有限序列：123456789&gt;&gt;&gt; from itertools import islice&gt;&gt;&gt; colors = cycle(['red', 'white', 'blue']) # infinite&gt;&gt;&gt; limited = islice(colors, 0, 4) # finite&gt;&gt;&gt; for x in limited: ... print(x)redwhitebluered为了更直观地感受迭代器内部的执行过程，我们自定义一个迭代器，以斐波那契数列为例：1234567891011121314151617class Fib: def __init__(self): self.prev = 0 self.curr = 1 def __iter__(self): return self def __next__(self): value = self.curr self.curr += self.prev self.prev = value return value&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; list(islice(f, 0, 10))[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]Fib既是一个可迭代对象（因为它实现了iter方法），又是一个迭代器（因为实现了next方法）。实例变量prev和curr用户维护迭代器内部的状态。每次调用next()方法的时候做两件事：为下一次调用next()方法修改状态为当前这次调用生成返回结果迭代器就像一个懒加载的工厂，等到有人需要的时候才给它生成值返回，没调用的时候就处于休眠状态等待下一次调用。可迭代对象和迭代器的分开自定义使用迭代器时,需要注意的一点是:迭代器只能迭代一次，每次调用调用 next() 方法就会向前一步，不能回退，只能如过河的卒子，不断向前。另外，迭代器也不适合在多线程环境中对可变集合使用。1234567891011121314151617181920class MyRange(object): def __init__(self, n): self.idx = 0 self.n = n def __iter__(self): return self def next(self): if self.idx &lt; self.n: val = self.idx self.idx += 1 return val else: raise StopIteration()myRange = MyRange(3)print [i for i in myRange]print [i for i in myRange]运行结果123True[0, 1, 2][]也就是说一个迭代器无法多次使用。为了解决这个问题，可以将可迭代对象和迭代器分开自定义：12345678910111213141516171819202122232425262728class Zrange: def __init__(self, n): self.n = n def __iter__(self): return ZrangeIterator(self.n)class ZrangeIterator: def __init__(self, n): self.i = 0 self.n = n def __iter__(self): return self def next(self): if self.i &lt; self.n: i = self.i self.i += 1 return i else: raise StopIteration()zrange = Zrange(3)print zrange is iter(zrange)print [i for i in zrange]print [i for i in zrange]生成器(generator)生成器算得上是Python语言中最吸引人的特性之一，生成器其实是一种特殊的迭代器，不过这种迭代器更加优雅。它不需要再像上面的类一样写__iter__()和__next__()方法了，只需要一个yiled关键字。 生成器一定是迭代器（反之不成立），因此任何生成器也是以一种懒加载的模式生成值。用生成器来实现斐波那契数列的例子是：123456789def fib(): prev, curr = 0, 1 while True: yield curr prev, curr = curr, curr + prev&gt;&gt;&gt; f = fib()&gt;&gt;&gt; list(islice(f, 0, 10))[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]fib就是一个普通的python函数，它特殊的地方在于函数体中没有return关键字，函数的返回值是一个生成器对象。当执行f=fib()返回的是一个生成器对象，此时函数体中的代码并不会执行，只有显示或隐示地调用next的时候才会真正执行里面的代码。生成器在Python中是一个非常强大的编程结构，可以用更少地中间变量写流式代码，此外，相比其它容器对象它更能节省内存和CPU，当然它可以用更少的代码来实现相似的功能。现在就可以动手重构你的代码了，但凡看到类似：12345def something(): result = [] for ... in ...: result.append(x) return result都可以用生成器函数来替代123def iter_something(): for ... in ...: yield x生成器表达式(generator expression)生成器表达式是列表推倒式的生成器版本，看起来像列表推导式，但是它返回的是一个生成器对象而不是列表对象。生成器表达式有一个特点，就是惰性计算。惰性计算这个特点很有用惰性计算想像成水龙头，需要的时候打开，接完水了关掉，这时候数据流就暂停了，再需要的时候再打开水龙头，这时候数据仍是接着输出，不需要从头开始循环.123456789101112def add(s, x): return s + xdef gen(): for i in range(4): yield ibase = gen()for n in [1, 10]: base = (add(i, n) for i in base)print list(base)结果输出是 [20,21,22,23]。很多人可能会想不明白，这里确实也很难理解，主要是因为生成器惰性计算的原因。生成器 base 在最后 list(base) 时被检索，此时生成器被赋值并开始计算。但此时 base 生成器一共被创建了三次，而且 n=10，这里注意 add(i+n) 绑定的是 n 这个变量而不是它当时的值（因为生成器在被检索时被赋值）。这样，首先通过 gen() 得到 (0, 1, 2, 3)，然后是第一次循环得到 (10 + 0, 10 + 1, 10 + 2, 10 +3)，最后是第二次循环得到 (10 + 10, 11 + 10, 12 + 10, 13 + 10)。这里可以用管道的思路来理解这个例子。首先 gen() 函数是第一个生成器，下一个是第一次循环的 base = (add(i, n) for i in base)， 最后一个生成器是第二次循环的 base = (add(i, n) for i in base)。这样就相当于三个管道依次连接，但是水(数据)还没有流过，现在到了 list(base)，就相当于驱动器，打开了水的开关，这时候，按照管道的顺序，由第一个产生一个数据，yield 0，然后第一个管道关闭。之后传递给第二个管道就是第一次循环,此时执行了add(0, 10)，然后水继续流，到第二次循环，再执行add(10, 10),此时到管道尾巴了，此时产生了第一个数据20，然后第一个管道再开放：yield 1， 流程跟上面的一样，依次产生21,22,23；直到没有数据。上面的例子就类似与下面这样的简单写法：12345678def gen(): for i in range(4): yield i # 第一个管道base = (add(i, 10) for i in base) # 第二个管道base = (add(i, 10) for i in base) # 第三个管道list(base) # 开关驱动器12345&gt;&gt;&gt; a = (x*x for x in range(10))&gt;&gt;&gt; a&lt;generator object &lt;genexpr&gt; at 0x401f08&gt;&gt;&gt;&gt; sum(a)285迭代器节省内存的真相迭代器能够很好的节能内存，这是因为它不必一次性将数据全部加载到内存中，而是在需要的时候产生一个结果。这在数据量的时候是非常有用的。1234l = range(100000000)for i in l: pass这个例子只是去遍历一个超大的列表，并没有做其他任何多余的操作。但是，在我的机器上运行时内存已经被占满，而且系统几乎卡死。但如果使用迭代器结果就不一样了：1234 l = xrange(100000000)for i in l: pass这样修改后程序只在 4s 左右就执行完成了，并且对系统没有任何影响。但是，需要注意的一点是：并非所有的迭代器都能很好的节省内存。例如：1234l = range(100000000)for i in iter(l): pass这里虽然在迭代时把列表转化成了迭代器，但是所有的数据已经放在内存中，并不会带来任何的效益。所以，并不是所有的迭代器都能节省内存，只有那些在需要时才产生一个结果的迭代器才有节省内存的特性。迭代器速度有听说迭代器的速度比列表、元组等容器对象快，这个说法太绝对，我也没有找到一个有力的证据证明迭代器总是比容器对象快。但在某些情况下，迭代器的效率确实会高些，容器对象需要把所有的数据加载到内存中，而读写内存也要消耗时间。因此，在某些情况下，速度会比较快。但是，要明白一点，不是所有的迭代器都能节省内存。说到速度，这里提一点：在 python 中， map和列表解析要比手动的 for 运行更快，而且更加精简、优雅。因为他们的迭代在解析器内部是以 C 语言的速度执行的，而不是以手动 python 代码执行的，特别对于较大的数据集合，这也是使用 map 函数和列表解析的一个主要的性能优点。但需要注意的一点是，在 python3 之后，map 函数不再返回一个 list，而是返回一个迭代器。总结容器是一系列元素的集合，str、list、set、dict、file、sockets对象都可以看作是容器，容器都可以被迭代（用在for，while等语句中），因此他们被称为可迭代对象。可迭代对象实现了__iter__方法，该方法返回一个迭代器对象。迭代器持有一个内部状态的字段，用于记录下次迭代返回值，它实现了__next__和__iter__方法，迭代器不会一次性把所有元素加载到内存，而是需要的时候才生成返回结果。生成器是一种特殊的迭代器，它的返回值不是通过return而是用yield。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>迭代器</tag>
        <tag>生成器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 数字签名]]></title>
    <url>%2FiOS%2Fa744f54b%2F</url>
    <content type="text"><![CDATA[为什么需要签名机制在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。数字签名数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。数字证书现实生活中的证书证书顾名思义，就是权限机构的颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：被证明人：老王内容：通过了英语六级盖章：教育部门的公章或钢印于是老王就可以用这张证书找工作了，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。在现实生活中，经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而这些问题在数字签名面前都可以用数学的方法严谨的解决。数字证书: 用数字签名实现的证书实际上，数字证书就是通过数字签名实现的数字化的证书。在一般的证书组成部分中，还加入了其他的信息，比如证书有效期（好比驾驶证初次申领后6年有效），过了有效期，需要重新签发（驾驶证6年有效后需重新申领）。跟现实生活中的签发机构一样，数字证书的签发机构也有若干，并有不同的用处。比如苹果公司就可以签发跟苹果公司有关的证书，而跟web访问有关的证书则是又几家公认的机构进行签发。这些签发机构称为CA（Certificate Authority）。对于被签发人，通常都是企业或开发者。比如需要搭建基于SSL的网站，那么需要从几家国际公认的CA去申请证书；再比如需要开发iOS的应用程序，需要从苹果公司获得相关的证书。这些申请通常是企业或者开发者个人提交给CA的。当然申请所需要的材料、资质和费用都各不相同，是由这些CA制定的，比如苹果要求$99或者$299的费用。之所以要申请证书，当然是为了被验证。英语6级证书的验证方一般是用人单位；web应用相关的SSL证书的验证方通常是浏览器；iOS各种证书的验证方是iOS设备。我们之所以必须从CA处申请证书，就是因为CA已经将整个验证过程规定好了。对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过。证书授权链数字证书可能还包括证书链信息。举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。我们从苹果MC（Member Center）中获得的证书实际也是一个包含有证书链的证书，其中的根是苹果的CA。我们获得的证书实际上是在告诉iOS设备：我们的证书是被苹果CA签过名的合法的证书。而iOS设备在执行app前，首先要先验证CA的签名是否合法，然后再通过证书中我们的公钥验证程序是否的确是我们发布的，且中途没有对程序进行过篡改。iOS证书申请和签名打包流程图证书申请花钱成为开发者安装苹果开发者根证书生成CertificateSigningRequest.certSigningRequest申请者信息，此信息是用申请者的私钥加密的申请者公钥，此信息是申请者使用的私钥对应的公钥摘要算法和公钥加密算法4.苹果取出CertificateSigningRequest.certSigningRequest中的公钥，根本不管我的其他信息，然后将我的MC账号信息和我提交的公钥封装在证书中，并进行数字签名。其中最为重要的是我的公钥，这个公钥与我本机的私钥是对应的。当我们双击安装完证书后，KeyChain会自动将这对密钥关联起来,所以在KeyChain中可以看到类似的效果：后续在程序上真机的过程中，会使用这个私钥，对代码进行签名，而公钥会附带在mobileprovision文件中，打包进app。注意这里，公钥是附带在mobileprovision中的，并不是直接随代码打包的，所以，笔者认为，本质上在电脑上安装证书是没有实际用处的，因为mobileprovision是MC为我们生成的。之所以需要安装证书，是因为签名程序codesign或者Xcode，只能让我们选择“用哪个证书签名”，因为我们所选的证书还是会对应到私钥，真正用于签名的是私钥。mobileprovision和代码签名在后面详细说明。所以，就算你有证书，但是如果没有对应的私钥是没有用的。那么有人要问了，既然私钥只有某台电脑生成的，那么团队开发怎么展开呢团队开发于是，大家会去搜索“iOS证书共享”之类的关键字，给出的解决方案就是“私钥导出”。没错，既然问题的关键是私钥，我们共享私钥不就行了，将最初申请证书的机器的私钥导出成.p12文件，并让其他机器导入，同时其他机器也应该安装下载下来的证书。当然还有一种方案，就是每台机器都各自去申请各自的证书。然而这样做可能到后面比较混乱。由于iOS证书有多种类型，用于不同的用处，所以我们可能后续还会去MC上申请别的证书。所以强烈建议CertificateSigningRequest.certSigningRequest需要保留，因为如果再次生成CertificateSigningRequest.certSigningRequest文件，可能就是对应另一个私钥了！还需要在共享一次私钥，会比较麻烦。iOS 证书类型当我们在MC的申请证书界面点击新建证书时，需要选择一种证书。每种证书有不同的用处，就好比你要生孩子，那么得有准生证；你要驾驶机动车，需要驾驶证；你要出国，需要护照…那么在iOS开发中涉及的证书究竟有什么区别呢？本质上他们的区别只是用途，从证书结构上讲都是同一个，只要你不改变申请用的CertificateSigningRequest.certSigningRequest文件，这些证书中包含的公钥和对应的私钥都是同一个。接下来罗列几个常用的证书类型：iOS App Development。开发、真机调试用Apple Push Notification service SSL (Sandbox)。开发阶段使用苹果的推送服务App Store and Ad Hoc。上架和AdHoc方式发布时用Apple Push Notification service SSL (Production)。上架后使用苹果推送服务In-House。企业版发布，需$299才能拥有，还需邓氏编码iOS授权和描述文件但是光有证书并不够解决苹果的“后顾之忧”，证书能够证明app的所属以及app的完整性，保证app本身是安全的。但是，却不能细化到app所使用的某些服务是被苹果认可的，比如APN推送服务。而且证书无法限制调试版的app的装机规模。于是，苹果想出了“花式作死”的mobileprovision。你可以使用如下命令查看一个mobileprovision：security cms -D -i embedded.mobileprovisionmobileprovision文件包含：AppId。每个app必须在MC中创建一个对应的AppId。规则不累述了。使用哪些证书。上面说了，不同类型的证书就代表了不同的发布方式，还包括一些功能的能否使用（比如APN）功能授权列表可安装的设备列表。对于AdHoc方式发布的app或者真机调试时，会有一个列表，这个列表里面是iOS设备的UDID，每台iOS设备出厂的UDID都不同，所以可以用来标识设备。可通过iTunes连接设备，或者http://fir.im/udid这里获取苹果的签名！注意5，这里的签名是苹果签的，跟我们的私钥没有关系。也就是说mobileprovision文件是苹果签名的，我们除了从MC中获取，别无他法。也不能再获取后随意篡改（比如添加别的设备）。因此上面的1-4就被苹果牢牢的控制在手里，所有的规则都必须由苹果来制定和约束。AdHoc发布和真机调试AdHoc允许将测试版app发布给有限的设备安装，而无需通过appstore的审核。这里的关键是如何控制哪些设备可以装。答案就是mobileprovision文件，记得你在生成mobileprovision文件的时候需要选设备的UDID吧，所以这些设备需要事先添加到MC的Devices里面。对于开发时候的真机调试，原理差不多。都是通过mobileprovision的条目4来做到的。而苹果对于调试和测试用机的数量限制为100台！iOS代码签名ipa的组成事实上，ipa文件只是一个zip包，可以使用如下命令解压：/usr/bin/unzip -q xxx.ipa -d &lt;destination&gt;解压后，得到上图的Payload目录，下面是个子目录，其中的内容如下：资源文件，例如图片、html、等等。_CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。可执行文件。此文件跟资源文件一样需要签名。一个mobileprovision文件.打包的时候使用的，从MC上生成的。Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件相关的程序和命令一般我们会用Xcode自带的archive功能来打包ipa和签名，实际上xcode只不过是调用了一些外部程序完成了工作，如果我们有朝一日需要自己实现自动化的签名流程，就需要了解究竟相关的程序和命令有哪些。用下面命令，列出系统中可用于签名的有效证书：/usr/bin/security find-identity -v -p codesigning1231) E056929276F94152F3FDF0EA84BD2B06396F2DDD "iPhone Developer: Liang Ding (2U967A2YJ6)"2) 7C608F653A989E95E1A4D303EC4E6625D95EEB42 "iPhone Distribution: Liang Ding (7XPNRZE9TC)" 2 valid identities found可以看到这个命令列出了一个字符串标示的证书名称，如：iPhone Developer: Liang Ding (2U967A2YJ6)。这个名称后面会用到的。使用如下命令对xxx.app目录签名，codesign程序会自动将其中的文件都签名，（Frameworks不会自动签）：/user/bin/codesign -fs &quot;iPhone Developer: Liang Ding (2U967A2YJ6)&quot; --no-strict Payload/xxx.app对于每个Framework，也需要使用这个命令签名，上面说了Framework的结构跟app其实差不多，所以签名命令类似。这个命令会自动找到证书相关的私钥。-f表示对于已经签名的app强制重签。最后用下面命令校验签名是否合法：/usr/bin/codesign -v xxx.app如果没有任何输出说明没有问题。使用zip命令重新打包成ipa包/usr/bin/zip -qry destination source对app重新签名的流程如果要设计一个自动化的重签程序，大致需要这么个流程：首先解压ipa如果mobileprovision需要替换，替换如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework对xxx.app签名重新打包iOS设备如何验证app是否合法关键的几个点：解压ipa取出embedded.mobileprovision，通过签名校验是否被篡改过 a. 其中有几个证书的公钥，其中开发证书和发布证书用于校验签名 b. BundleId c. 授权列表校验所有文件的签名，包括Frameworks比对Info.plist里面的BundleId是否符合embedded.mobileprovision文件中的最简单的前面要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：开发 App 时可以直接把开发中的应用安装进手机进行调试。In-House 企业内部分发，可以直接安装企业证书签名后的 APP。AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。非APP Store其他方式我们先来看第一个，开发时安装APP，它有两个个需求：安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。苹果必须对这里的安装有控制权，包括a.经过苹果允许才可以这样安装。b.不能被滥用导致非开发app也能被安装。为了实现这些需求，iOS 签名的复杂度也就开始增加了。苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）补充上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。最终流程到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。所以整个流程稍微变一下，就变成这样了：因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。概念与操作上面的步骤对应到我们平常具体的操作和概念是这样的：第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一堆公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。第 2 步苹果处理，不用管。第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。第 6 - 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。这里再总结一下这些概念：证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。Entitlements：包含了 App 权限开关列表。CertificateSigningRequest：本地公钥。p12：本地私钥，可以导入到其他电脑。Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。其它发布方式前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。最后这里再提一下我关于签名流程的一些的疑问。企业证书企业证书签名因为限制少，在国内被广泛用于测试和盗版，fir.im / 蒲公英等测试平台都是通过企业证书分发，国内一些市场像 PP 助手，爱思助手，一部分安装手段也是通过企业证书重签名。通过企业证书签名安装的 App，启动时都会验证证书的有效期，并且不定期请求苹果服务器看证书是否被吊销，若已过期或被吊销，就会无法启动 App。对于这种助手的盗版安装手段，苹果想打击只能一个个吊销企业证书，并没有太好的办法。这里我的疑问是，苹果做了那么多签名和验证机制去限制在 iOS 安装 App，为什么又要出这样一个限制很少的方式让盗版钻空子呢？若真的是企业用途不适合上 AppStore，也完全可以在 AppStore 开辟一个小的私密版块，还是通过 AppStore 去安装，就不会有这个问题了。AppStore 加密另一个问题是我们把 App 传上 AppStore 后，苹果会对 App 进行加密，导致 App 体积增大不少，这个加密实际上是没卵用的，只是让破解的人要多做一个步骤，运行 App 去内存 dump 出可执行文件而已，无论怎样加密，都可以用这种方式拿出加密前的可执行文件。所以为什么要做这样的加密呢？想不到有什么好处。本地私钥我们看到前面说的签名流程很绕很复杂，经常出现各种问题，像有 Provisioning Profile 文件但证书又不对，本地有公钥证书没对应私钥等情况，不理解原理的情况下会被绕晕，我的疑问是，这里为什么不能简化呢？还是以开发证书为例，为什么一定要用本地 Mac 生成的私钥去签名？苹果要的只是本地签名，私钥不一定是要本地生成的，苹果也可以自己生成一对公私钥给我们，放在 Provisioning Profile 里，我们用里面的私钥去加密就行了，这样就不会有 CertificateSigningRequest 和 p12 的概念，跟本地 keychain 没有关系，不需要关心证书，只要有 Provisioning Profile 就能签名，流程会减少，易用性会提高很多，同时苹果想要的控制一点都不会少，也没有什么安全问题，为什么不这样设计呢？能想到的一个原因是 Provisioning Profile 在非 AppStore 安装时会打包进安装包，第三方拿到这个 Provisioning Profile 文件就能直接用起来给他自己的 App 签名了。但这种问题也挺好解决，只需要打包时去掉文件里的私钥就行了，所以仍不明白为什么这样设计。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>加密</tag>
        <tag>签名</tag>
      </tags>
  </entry>
</search>
