<!-- build time:Sun Aug 05 2018 15:43:21 GMT+0000 (UTC) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><script src="https://cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="https://cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css" rel="stylesheet"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="https://cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0"><link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222"><link rel="manifest" href="/images/manifest.json"><meta name="msapplication-config" content="/images/browserconfig.xml"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.3.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="为什么需要签名机制在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。数字签名数字签名的作用是我对某一份"><meta name="keywords" content="加密,签名"><meta property="og:type" content="article"><meta property="og:title" content="iOS 数字签名"><meta property="og:url" content="yuanchunxiang.com/iOS/a744f54b/index.html"><meta property="og:site_name" content="Mr. Song&#39;s blog"><meta property="og:description" content="为什么需要签名机制在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。数字签名数字签名的作用是我对某一份"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:image" content="/images/loading.gif"><meta property="og:updated_time" content="2018-05-18T00:00:00.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="iOS 数字签名"><meta name="twitter:description" content="为什么需要签名机制在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。数字签名数字签名的作用是我对某一份"><meta name="twitter:image" content="/images/loading.gif"><link rel="canonical" href="yuanchunxiang.com/iOS/a744f54b/"><script type="text/javascript" id="page.configurations">CONFIG.page={sidebar:""}</script><title>iOS 数字签名 | Mr. Song's blog</title><noscript><style type="text/css">.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Mr. Song's blog</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">完成比完美更重要</h1></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><div class="reading-progress-bar"></div><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="yuanchunxiang.com/iOS/a744f54b/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="水煮冰"><meta itemprop="description" content="Developer"><meta itemprop="image" content="http://pizisong.qiniudn.com/2018-03-07-242A24248E97D9E34F227152EC05F2AD.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Mr. Song's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">iOS 数字签名</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2018-05-15T00:00:00Z">2018-05-15</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-05-18 00:00:00" itemprop="dateModified" datetime="2018-05-18T00:00:00Z">2018-05-18</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/iOS/a744f54b/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count gitment-comments-count" data-xid="/iOS/a744f54b/" itemprop="commentsCount"></span></a></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">11k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">20 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="为什么需要签名机制"><a href="#为什么需要签名机制" class="headerlink" title="为什么需要签名机制"></a>为什么需要签名机制</h2><p>在 iOS 出来之前，在主流操作系统(Mac/Windows/Linux)上开发和运行软件是不需要签名的，软件随便从哪里下载都能运行，导致平台对第三方软件难以控制，盗版流行。苹果希望解决这样的问题，在 iOS 平台对第三方 APP 有绝对的控制权，一定要保证每一个安装到 iOS 上的 APP 都是经过苹果官方允许的，怎样保证呢？就是通过签名机制。</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名的作用是我对某一份数据打个标记，表示我认可了这份数据（签了个名），然后我发送给其他人，其他人可以知道这份数据是经过我认证的，数据没有被篡改过。<br><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15257627634857.jpg?imageView2/2/h/320" alt=""><br><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15259344204584.jpg?imageView2/2/h/320" alt=""></p><ol><li>首先用一种算法，算出原始数据的摘要。需满足 a.若原始数据有任何变化，计算出来的摘要值都会变化。 b.摘要要够短。这里最常用的算法是MD5。</li><li>生成一份非对称加密的公钥和私钥，私钥我自己拿着，公钥公布出去。</li><li>对一份数据，算出摘要后，用私钥加密这个摘要，得到一份加密后的数据，称为原始数据的签名。把它跟原始数据一起发送给用户。</li><li>用户收到数据和签名后，用公钥解密得到摘要。同时用户用同样的算法计算原始数据的摘要，对比这里计算出来的摘要和用公钥解密签名得到的摘要是否相等，若相等则表示这份数据中途没有被篡改过，因为如果篡改过，摘要会变化。</li></ol><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><h3 id="现实生活中的证书"><a href="#现实生活中的证书" class="headerlink" title="现实生活中的证书"></a>现实生活中的证书</h3><p>证书顾名思义，就是权限机构的颁发的证明。比如英语6级证书，就是教育部门颁发给通过了6级考核的个人的证明，证明这个人的英语能力。我们来看一下这个证书的组成：</p><ul><li>被证明人：老王</li><li>内容：通过了英语六级</li><li>盖章：教育部门的公章或钢印</li></ul><p>于是老王就可以用这张证书找工作了，用人单位会通过查看证书的各项内容（尤其是公章），来验证证书的合法性和老王的能力。<br>在现实生活中，经常有假的6级证书，这些假证书最重要的就是有一个假公章。现实生活中使用法律法规来约束私刻假公章的行为，但是用人单位可能不能十分准确的判断公章是真是假。而这些问题在数字签名面前都可以用数学的方法严谨的解决。</p><h3 id="数字证书-用数字签名实现的证书"><a href="#数字证书-用数字签名实现的证书" class="headerlink" title="数字证书: 用数字签名实现的证书"></a>数字证书: 用数字签名实现的证书</h3><p>实际上，数字证书就是通过数字签名实现的数字化的证书。在一般的证书组成部分中，还加入了其他的信息，比如证书有效期（好比驾驶证初次申领后6年有效），过了有效期，需要重新签发（驾驶证6年有效后需重新申领）。</p><p>跟现实生活中的签发机构一样，数字证书的签发机构也有若干，并有不同的用处。比如苹果公司就可以签发跟苹果公司有关的证书，而跟web访问有关的证书则是又几家公认的机构进行签发。这些签发机构称为CA（Certificate Authority）。</p><p>对于被签发人，通常都是企业或开发者。比如需要搭建基于SSL的网站，那么需要从几家国际公认的CA去申请证书；再比如需要开发iOS的应用程序，需要从苹果公司获得相关的证书。这些申请通常是企业或者开发者个人提交给CA的。当然申请所需要的材料、资质和费用都各不相同，是由这些CA制定的，比如苹果要求$99或者$299的费用。</p><p>之所以要申请证书，当然是为了被验证。英语6级证书的验证方一般是用人单位；web应用相关的SSL证书的验证方通常是浏览器；iOS各种证书的验证方是iOS设备。我们之所以必须从CA处申请证书，就是因为CA已经将整个验证过程规定好了。对于iOS，iOS系统已经将这个验证过程固化在系统中了，除非越狱，否则无法绕过。</p><h3 id="证书授权链"><a href="#证书授权链" class="headerlink" title="证书授权链"></a>证书授权链</h3><p>数字证书可能还包括证书链信息。举个例子：如果你要申请休假1周，需要你的上司审批，你的上司需要他的上司同意，最终需要大老板同意，那么这一层层的授权，形成了一个授权链，大老板是授权链的根(root)，中间这些环节分别是被更接近root的人授权的。</p><p>我们从苹果MC（Member Center）中获得的证书实际也是一个包含有证书链的证书，其中的根是苹果的CA。我们获得的证书实际上是在告诉iOS设备：我们的证书是被苹果CA签过名的合法的证书。而iOS设备在执行app前，首先要先验证CA的签名是否合法，然后再通过证书中我们的公钥验证程序是否的确是我们发布的，且中途没有对程序进行过篡改。</p><h3 id="iOS证书申请和签名打包流程图"><a href="#iOS证书申请和签名打包流程图" class="headerlink" title="iOS证书申请和签名打包流程图"></a>iOS证书申请和签名打包流程图</h3><p><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15259347352503.jpg?imageView2/2/h/320" alt=""></p><h4 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h4><ol><li>花钱成为开发者</li><li>安装苹果开发者根证书</li></ol><p><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15259348682820.jpg?imageView2/2/h/320" alt=""></p><ol start="3"><li><p>生成CertificateSigningRequest.certSigningRequest</p><ul><li>申请者信息，此信息是用申请者的私钥加密的</li><li>申请者公钥，此信息是申请者使用的私钥对应的公钥</li><li>摘要算法和公钥加密算法<br>4.苹果取出CertificateSigningRequest.certSigningRequest中的公钥，根本不管我的其他信息，然后将我的MC账号信息和我提交的公钥封装在证书中，并进行数字签名。<br>其中最为重要的是我的公钥，这个公钥与我本机的私钥是对应的。当我们双击安装完证书后，KeyChain会自动将这对密钥关联起来,所以在KeyChain中可以看到类似的效果：后续在程序上真机的过程中，会使用这个私钥，对代码进行签名，而公钥会附带在mobileprovision文件中，打包进app。</li></ul></li></ol><blockquote><blockquote><blockquote><p>注意这里，公钥是附带在mobileprovision中的，并不是直接随代码打包的，所以，笔者认为，本质上在电脑上安装证书是没有实际用处的，因为mobileprovision是MC为我们生成的。之所以需要安装证书，是因为签名程序codesign或者Xcode，只能让我们选择“用哪个证书签名”，因为我们所选的证书还是会对应到私钥，真正用于签名的是私钥。mobileprovision和代码签名在后面详细说明。</p></blockquote></blockquote></blockquote><p>所以，就算你有证书，但是如果没有对应的私钥是没有用的。那么有人要问了，既然私钥只有某台电脑生成的，那么团队开发怎么展开呢</p><h4 id="团队开发"><a href="#团队开发" class="headerlink" title="团队开发"></a>团队开发</h4><p>于是，大家会去搜索“iOS证书共享”之类的关键字，给出的解决方案就是“私钥导出”。没错，既然问题的关键是私钥，我们共享私钥不就行了，将最初申请证书的机器的私钥导出成.p12文件，并让其他机器导入，同时其他机器也应该安装下载下来的证书。</p><p>当然还有一种方案，就是每台机器都各自去申请各自的证书。然而这样做可能到后面比较混乱。<br>由于iOS证书有多种类型，用于不同的用处，所以我们可能后续还会去MC上申请别的证书。所以强烈建议CertificateSigningRequest.certSigningRequest需要保留，因为如果再次生成CertificateSigningRequest.certSigningRequest文件，可能就是对应另一个私钥了！还需要在共享一次私钥，会比较麻烦。</p><h4 id="iOS-证书类型"><a href="#iOS-证书类型" class="headerlink" title="iOS 证书类型"></a>iOS 证书类型</h4><p>当我们在MC的申请证书界面点击新建证书时，需要选择一种证书。每种证书有不同的用处，就好比你要生孩子，那么得有准生证；你要驾驶机动车，需要驾驶证；你要出国，需要护照…那么在iOS开发中涉及的证书究竟有什么区别呢？本质上他们的区别只是用途，从证书结构上讲都是同一个，只要你不改变申请用的CertificateSigningRequest.certSigningRequest文件，这些证书中包含的公钥和对应的私钥都是同一个。接下来罗列几个常用的证书类型：</p><ol><li>iOS App Development。开发、真机调试用</li><li>Apple Push Notification service SSL (Sandbox)。开发阶段使用苹果的推送服务</li><li>App Store and Ad Hoc。上架和AdHoc方式发布时用</li><li>Apple Push Notification service SSL (Production)。上架后使用苹果推送服务</li><li>In-House。企业版发布，需$299才能拥有，还需邓氏编码</li></ol><h4 id="iOS授权和描述文件"><a href="#iOS授权和描述文件" class="headerlink" title="iOS授权和描述文件"></a>iOS授权和描述文件</h4><p>但是光有证书并不够解决苹果的“后顾之忧”，证书能够证明app的所属以及app的完整性，保证app本身是安全的。但是，却不能细化到app所使用的某些服务是被苹果认可的，比如APN推送服务。而且证书无法限制调试版的app的装机规模。于是，苹果想出了“花式作死”的mobileprovision。你可以使用如下命令查看一个mobileprovision：<br><code>security cms -D -i embedded.mobileprovision</code><br>mobileprovision文件包含：</p><ol><li>AppId。每个app必须在MC中创建一个对应的AppId。规则不累述了。</li><li>使用哪些证书。上面说了，不同类型的证书就代表了不同的发布方式，还包括一些功能的能否使用（比如APN）</li><li>功能授权列表</li><li>可安装的设备列表。对于AdHoc方式发布的app或者真机调试时，会有一个列表，这个列表里面是iOS设备的UDID，每台iOS设备出厂的UDID都不同，所以可以用来标识设备。可通过iTunes连接设备，或者<a href="http://fir.im/udid这里获取" target="_blank" rel="noopener">http://fir.im/udid这里获取</a></li><li>苹果的签名！</li></ol><p>注意5，这里的签名是苹果签的，跟我们的私钥没有关系。也就是说mobileprovision文件是苹果签名的，我们除了从MC中获取，别无他法。也不能再获取后随意篡改（比如添加别的设备）。因此上面的1-4就被苹果牢牢的控制在手里，所有的规则都必须由苹果来制定和约束。</p><h4 id="AdHoc发布和真机调试"><a href="#AdHoc发布和真机调试" class="headerlink" title="AdHoc发布和真机调试"></a>AdHoc发布和真机调试</h4><p>AdHoc允许将测试版app发布给有限的设备安装，而无需通过appstore的审核。这里的关键是如何控制哪些设备可以装。答案就是mobileprovision文件，记得你在生成mobileprovision文件的时候需要选设备的UDID吧，所以这些设备需要事先添加到MC的Devices里面。对于开发时候的真机调试，原理差不多。都是通过mobileprovision的条目4来做到的。而苹果对于调试和测试用机的数量限制为100台！</p><h3 id="iOS代码签名"><a href="#iOS代码签名" class="headerlink" title="iOS代码签名"></a>iOS代码签名</h3><h4 id="ipa的组成"><a href="#ipa的组成" class="headerlink" title="ipa的组成"></a>ipa的组成</h4><p><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15259358025535.jpg?imageView2/2/h/320" alt=""><br>事实上，ipa文件只是一个zip包，可以使用如下命令解压：<br><code>/usr/bin/unzip -q xxx.ipa -d &lt;destination&gt;</code><br>解压后，得到上图的Payload目录，下面是个子目录，其中的内容如下：</p><ol><li>资源文件，例如图片、html、等等。</li><li>_CodeSignature/CodeResources。这是一个plist文件，可用文本查看，其中的内容就是是程序包中（不包括Frameworks）所有文件的签名。注意这里是所有文件。意味着你的程序一旦签名，就不能更改其中任何的东西，包括资源文件和可执行文件本身。iOS系统会检查这些签名。</li><li>可执行文件。此文件跟资源文件一样需要签名。</li><li>一个mobileprovision文件.打包的时候使用的，从MC上生成的。</li><li>Frameworks。程序引用的非系统自带的Frameworks，每个Frameworks其实就是一个app，其中的结构应该和app差不多，也包含签名信息CodeResources文件</li></ol><h4 id="相关的程序和命令"><a href="#相关的程序和命令" class="headerlink" title="相关的程序和命令"></a>相关的程序和命令</h4><p>一般我们会用Xcode自带的archive功能来打包ipa和签名，实际上xcode只不过是调用了一些外部程序完成了工作，如果我们有朝一日需要自己实现自动化的签名流程，就需要了解究竟相关的程序和命令有哪些。<br>用下面命令，列出系统中可用于签名的有效证书：<br><code>/usr/bin/security find-identity -v -p codesigning</code><br></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) E056929276F94152F3FDF0EA84BD2B06396F2DDD <span class="string">"iPhone Developer: Liang Ding (2U967A2YJ6)"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">7</span>C608F653A989E95E1A4D303EC4E6625D95EEB42 <span class="string">"iPhone Distribution: Liang Ding (7XPNRZE9TC)"</span></span><br><span class="line">  <span class="number">2</span> valid identities found</span><br></pre></td></tr></table></figure><p></p><p>可以看到这个命令列出了一个字符串标示的证书名称，如：iPhone Developer: Liang Ding (2U967A2YJ6)。这个名称后面会用到的。<br>使用如下命令对xxx.app目录签名，codesign程序会自动将其中的文件都签名，（Frameworks不会自动签）：<br><code>/user/bin/codesign -fs &quot;iPhone Developer: Liang Ding (2U967A2YJ6)&quot; --no-strict Payload/xxx.app</code><br>对于每个Framework，也需要使用这个命令签名，上面说了Framework的结构跟app其实差不多，所以签名命令类似。这个命令会自动找到证书相关的私钥。-f表示对于已经签名的app强制重签。<br>最后用下面命令校验签名是否合法：<br><code>/usr/bin/codesign -v xxx.app</code><br>如果没有任何输出说明没有问题。</p><p>使用zip命令重新打包成ipa包<br><code>/usr/bin/zip -qry destination source</code></p><h3 id="对app重新签名的流程"><a href="#对app重新签名的流程" class="headerlink" title="对app重新签名的流程"></a>对app重新签名的流程</h3><p>如果要设计一个自动化的重签程序，大致需要这么个流程：</p><p><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15259360532168.jpg?imageView2/2/h/320" alt=""></p><ol><li>首先解压ipa</li><li>如果mobileprovision需要替换，替换</li><li>如果存在Frameworks子目录，则对.app文件夹下的所有Frameworks进行签名，在Frameworks文件夹下的.dylib或.framework</li><li>对xxx.app签名</li><li>重新打包</li></ol><h4 id="iOS设备如何验证app是否合法"><a href="#iOS设备如何验证app是否合法" class="headerlink" title="iOS设备如何验证app是否合法"></a>iOS设备如何验证app是否合法</h4><p>关键的几个点：</p><ol><li>解压ipa</li><li>取出embedded.mobileprovision，通过签名校验是否被篡改过 a. 其中有几个证书的公钥，其中开发证书和发布证书用于校验签名 b. BundleId c. 授权列表</li><li>校验所有文件的签名，包括Frameworks</li><li>比对Info.plist里面的BundleId是否符合embedded.mobileprovision文件中的</li></ol><h2 id="最简单的前面"><a href="#最简单的前面" class="headerlink" title="最简单的前面"></a>最简单的前面</h2><p>要实现这个需求很简单，最直接的方式，苹果官方生成一对公私钥，在 iOS 里内置一个公钥，私钥由苹果后台保存，我们传 App 上 AppStore 时，苹果后台用私钥对 APP 数据进行签名，iOS 系统下载这个 APP 后，用公钥验证这个签名，若签名正确，这个 APP 肯定是由苹果后台认证的，并且没有被修改过，也就达到了苹果的需求：保证安装的每一个 APP 都是经过苹果官方允许的。<br><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15257629092248.jpg?imageView2/2/h/320" alt=""><br>如果我们 iOS 设备安装 APP 只有从 AppStore 下载这一种方式的话，这件事就结束了，没有任何复杂的东西，只有一个数字签名，非常简单地解决问题。</p><p>但实际上因为除了从 AppStore 下载，我们还可以有三种方式安装一个 App：</p><p>开发 App 时可以直接把开发中的应用安装进手机进行调试。<br>In-House 企业内部分发，可以直接安装企业证书签名后的 APP。<br>AD-Hoc 相当于企业分发的限制版，限制安装设备数量，较少用。<br>苹果要对用这三种方式安装的 App 进行控制，就有了新的需求，无法像上面这样简单了。</p><h2 id="非APP-Store其他方式"><a href="#非APP-Store其他方式" class="headerlink" title="非APP Store其他方式"></a>非APP Store其他方式</h2><p>我们先来看第一个，开发时安装APP，它有两个个需求：</p><ol><li>安装包不需要传到苹果服务器，可以直接安装到手机上。如果你编译一个 APP 到手机前要先传到苹果服务器签名，这显然是不能接受的。</li><li>苹果必须对这里的安装有控制权，包括<br>a.经过苹果允许才可以这样安装。<br>b.不能被滥用导致非开发app也能被安装。<br>为了实现这些需求，iOS 签名的复杂度也就开始增加了。</li></ol><p>苹果这里给出的方案是使用了双层签名，会比较绕，流程大概是这样的：</p><p><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15257629743655.jpg?imageView2/2/h/320" alt=""></p><ol><li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li><li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li><li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li><li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第三步得到的证书一起打包进 APP 里，安装到手机上。</li><li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证证书的数字签名是否正确。</li><li>验证证书后确保了公钥 L 是苹果认证过的，再用公钥 L 去验证 APP 的签名，这里就间接验证了这个 APP 安装行为是否经过苹果官方允许。（这里只验证安装行为，不验证APP 是否被改动，因为开发阶段 APP 内容总是不断变化的，苹果不需要管。）</li></ol><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>上述流程只解决了上面第一个需求，也就是需要经过苹果允许才可以安装，还未解决第二个避免被滥用的问题。怎么解决呢？苹果再加了两个限制，一是限制在苹果后台注册过的设备才可以安装，二是限制签名只能针对某一个具体的 APP。</p><p>怎么加的？在上述第三步，苹果用私钥 A 签名我们本地公钥 L 时，实际上除了签名公钥 L，还可以加上无限多数据，这些数据都可以保证是经过苹果官方认证的，不会有被篡改的可能。<br><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15257630352566.jpg?imageView2/2/h/320" alt=""></p><p>可以想到把 允许安装的设备 ID 列表 和 App对应的 AppID 等数据，都在第三步这里跟公钥L一起组成证书，再用苹果私钥 A 对这个证书签名。在最后第 5 步验证时就可以拿到设备 ID 列表，判断当前设备是否符合要求。根据数字签名的原理，只要数字签名通过验证，第 5 步这里的设备 IDs / AppID / 公钥 L 就都是经过苹果认证的，无法被修改，苹果就可以限制可安装的设备和 APP，避免滥用。</p><h2 id="最终流程"><a href="#最终流程" class="headerlink" title="最终流程"></a>最终流程</h2><p>到这里这个证书已经变得很复杂了，有很多额外信息，实际上除了 设备 ID / AppID，还有其他信息也需要在这里用苹果签名，像这个 APP 里 iCloud / push / 后台运行 等权限苹果都想控制，苹果把这些权限开关统一称为 Entitlements，它也需要通过签名去授权。</p><p>实际上一个“证书”本来就有规定的格式规范，上面我们把各种额外信息塞入证书里是不合适的，于是苹果另外搞了个东西，叫 Provisioning Profile，一个 Provisioning Profile 里就包含了证书以及上述提到的所有额外信息，以及所有信息的签名。</p><p>所以整个流程稍微变一下，就变成这样了：<br><img src="/images/loading.gif" data-original="http://pizisong.qiniudn.com/2018-05-11-15257630713231.jpg?imageView2/2/h/320" alt=""><br>因为步骤有小变动，这里我们不辞啰嗦重新再列一遍整个流程：</p><ol><li>在你的 Mac 开发机器生成一对公私钥，这里称为公钥L，私钥L。L:Local</li><li>苹果自己有固定的一对公私钥，跟上面 AppStore 例子一样，私钥在苹果后台，公钥在每个 iOS 设备上。这里称为公钥A，私钥A。A:Apple</li><li>把公钥 L 传到苹果后台，用苹果后台里的私钥 A 去签名公钥 L。得到一份数据包含了公钥 L 以及其签名，把这份数据称为证书。</li><li>在苹果后台申请 AppID，配置好设备 ID 列表和 APP 可使用的权限，再加上第③步的证书，组成的数据用私钥 A 签名，把数据和签名一起组成一个 Provisioning Profile 文件，下载到本地 Mac 开发机。</li><li>在开发时，编译完一个 APP 后，用本地的私钥 L 对这个 APP 进行签名，同时把第④步得到的 Provisioning Profile 文件打包进 APP 里，文件名为 embedded.mobileprovision，把 APP 安装到手机上。</li><li>在安装时，iOS 系统取得证书，通过系统内置的公钥 A，去验证 embedded.mobileprovision 的数字签名是否正确，里面的证书签名也会再验一遍。</li><li>确保了 embedded.mobileprovision 里的数据都是苹果授权以后，就可以取出里面的数据，做各种验证，包括用公钥 L 验证APP签名，验证设备 ID 是否在 ID 列表上，AppID 是否对应得上，权限开关是否跟 APP 里的 Entitlements 对应等。<br>开发者证书从签名到认证最终苹果采用的流程大致是这样，还有一些细节像证书有效期/证书类型等就不细说了。</li></ol><h2 id="概念与操作"><a href="#概念与操作" class="headerlink" title="概念与操作"></a>概念与操作</h2><p>上面的步骤对应到我们平常具体的操作和概念是这样的：</p><ol><li>第 1 步对应的是 keychain 里的 “从证书颁发机构请求证书”，这里就本地生成了一堆公私钥，保存的 CertificateSigningRequest 就是公钥，私钥保存在本地电脑里。</li><li>第 2 步苹果处理，不用管。</li><li>第 3 步对应把 CertificateSigningRequest 传到苹果后台生成证书，并下载到本地。这时本地有两个证书，一个是第 1 步生成的，一个是这里下载回来的，keychain 会把这两个证书关联起来，因为他们公私钥是对应的，在XCode选择下载回来的证书时，实际上会找到 keychain 里对应的私钥去签名。这里私钥只有生成它的这台 Mac 有，如果别的 Mac 也要编译签名这个 App 怎么办？答案是把私钥导出给其他 Mac 用，在 keychain 里导出私钥，就会存成 .p12 文件，其他 Mac 打开后就导入了这个私钥。</li><li>第 4 步都是在苹果网站上操作，配置 AppID / 权限 / 设备等，最后下载 Provisioning Profile 文件。</li><li>第 5 步 XCode 会通过第 3 步下载回来的证书（存着公钥），在本地找到对应的私钥（第一步生成的），用本地私钥去签名 App，并把 Provisioning Profile 文件命名为 embedded.mobileprovision 一起打包进去。这里对 App 的签名数据保存分两部分，Mach-O 可执行文件会把签名直接写入这个文件里，其他资源文件则会保存在 _CodeSignature 目录下。<br>第 6 - 7 步的打包和验证都是 Xcode 和 iOS 系统自动做的事。</li></ol><p>这里再总结一下这些概念：</p><ul><li>证书：内容是公钥或私钥，由其他机构对其签名组成的数据包。</li><li>Entitlements：包含了 App 权限开关列表。</li><li>CertificateSigningRequest：本地公钥。</li><li>p12：本地私钥，可以导入到其他电脑。</li><li>Provisioning Profile：包含了 证书 / Entitlements 等数据，并由苹果后台私钥签名的数据包。</li></ul><h2 id="其它发布方式"><a href="#其它发布方式" class="headerlink" title="其它发布方式"></a>其它发布方式</h2><p>前面以开发包为例子说了签名和验证的流程，另外两种方式 In-House 企业签名和 AD-Hoc 流程也是差不多的，只是企业签名不限制安装的设备数，另外需要用户在 iOS 系统设置上手动点击信任这个企业才能通过验证。</p><p>而 AppStore 的签名验证方式有些不一样，前面我们说到最简单的签名方式，苹果在后台直接用私钥签名 App 就可以了，实际上苹果确实是这样做的，如果去下载一个 AppStore 的安装包，会发现它里面是没有 embedded.mobileprovision 文件的，也就是它安装和启动的流程是不依赖这个文件，验证流程也就跟上述几种类型不一样了。</p><p>据猜测，因为上传到 AppStore 的包苹果会重新对内容加密，原来的本地私钥签名就没有用了，需要重新签名，从 AppStore 下载的包苹果也并不打算控制它的有效期，不需要内置一个 embedded.mobileprovision 去做校验，直接在苹果用后台的私钥重新签名，iOS 安装时用本地公钥验证 App 签名就可以了。</p><p>那为什么发布 AppStore 的包还是要跟开发版一样搞各种证书和 Provisioning Profile？猜测因为苹果想做统一管理，Provisioning Profile 里包含一些权限控制，AppID 的检验等，苹果不想在上传 AppStore 包时重新用另一种协议做一遍这些验证，就不如统一把这部分放在 Provisioning Profile 里，上传 AppStore 时只要用同样的流程验证这个 Provisioning Profile 是否合法就可以了。</p><p>所以 App 上传到 AppStore 后，就跟你的 证书 / Provisioning Profile 都没有关系了，无论他们是否过期或被废除，都不会影响 AppStore 上的安装包。</p><p>到这里 iOS 签名机制的原理和主流程大致说完了，希望能对理解苹果签名和排查日常签名问题有所帮助。</p><p>最后这里再提一下我关于签名流程的一些的疑问。</p><p>企业证书<br>企业证书签名因为限制少，在国内被广泛用于测试和盗版，fir.im / 蒲公英等测试平台都是通过企业证书分发，国内一些市场像 PP 助手，爱思助手，一部分安装手段也是通过企业证书重签名。通过企业证书签名安装的 App，启动时都会验证证书的有效期，并且不定期请求苹果服务器看证书是否被吊销，若已过期或被吊销，就会无法启动 App。对于这种助手的盗版安装手段，苹果想打击只能一个个吊销企业证书，并没有太好的办法。</p><p>这里我的疑问是，苹果做了那么多签名和验证机制去限制在 iOS 安装 App，为什么又要出这样一个限制很少的方式让盗版钻空子呢？若真的是企业用途不适合上 AppStore，也完全可以在 AppStore 开辟一个小的私密版块，还是通过 AppStore 去安装，就不会有这个问题了。</p><p>AppStore 加密<br>另一个问题是我们把 App 传上 AppStore 后，苹果会对 App 进行加密，导致 App 体积增大不少，这个加密实际上是没卵用的，只是让破解的人要多做一个步骤，运行 App 去内存 dump 出可执行文件而已，无论怎样加密，都可以用这种方式拿出加密前的可执行文件。所以为什么要做这样的加密呢？想不到有什么好处。</p><p>本地私钥<br>我们看到前面说的签名流程很绕很复杂，经常出现各种问题，像有 Provisioning Profile 文件但证书又不对，本地有公钥证书没对应私钥等情况，不理解原理的情况下会被绕晕，我的疑问是，这里为什么不能简化呢？还是以开发证书为例，为什么一定要用本地 Mac 生成的私钥去签名？苹果要的只是本地签名，私钥不一定是要本地生成的，苹果也可以自己生成一对公私钥给我们，放在 Provisioning Profile 里，我们用里面的私钥去加密就行了，这样就不会有 CertificateSigningRequest 和 p12 的概念，跟本地 keychain 没有关系，不需要关心证书，只要有 Provisioning Profile 就能签名，流程会减少，易用性会提高很多，同时苹果想要的控制一点都不会少，也没有什么安全问题，为什么不这样设计呢？</p><p>能想到的一个原因是 Provisioning Profile 在非 AppStore 安装时会打包进安装包，第三方拿到这个 Provisioning Profile 文件就能直接用起来给他自己的 App 签名了。但这种问题也挺好解决，只需要打包时去掉文件里的私钥就行了，所以仍不明白为什么这样设计。</p></div><footer class="post-footer"><div class="post-tags"><a href="/tags/加密/" rel="tag"><i class="fa fa-tag"></i> 加密</a> <a href="/tags/签名/" rel="tag"><i class="fa fa-tag"></i> 签名</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/python/2e39bde6/" rel="prev" title="Python 迭代器">Python 迭代器 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div onclick="showGitment()" id="gitment-display-button">显示 Gitment 评论</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://pizisong.qiniudn.com/2018-03-07-242A24248E97D9E34F227152EC05F2AD.jpg" alt="水煮冰"><p class="site-author-name" itemprop="name">水煮冰</p><p class="site-description motion-element" itemprop="description">Developer</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:996982027@qq.com" target="_blank" title="E-Mail" rel="external nofollow"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#为什么需要签名机制"><span class="nav-number">1.</span> <span class="nav-text">为什么需要签名机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数字签名"><span class="nav-number">2.</span> <span class="nav-text">数字签名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数字证书"><span class="nav-number">3.</span> <span class="nav-text">数字证书</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#现实生活中的证书"><span class="nav-number">3.1.</span> <span class="nav-text">现实生活中的证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字证书-用数字签名实现的证书"><span class="nav-number">3.2.</span> <span class="nav-text">数字证书: 用数字签名实现的证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#证书授权链"><span class="nav-number">3.3.</span> <span class="nav-text">证书授权链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS证书申请和签名打包流程图"><span class="nav-number">3.4.</span> <span class="nav-text">iOS证书申请和签名打包流程图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#证书申请"><span class="nav-number">3.4.1.</span> <span class="nav-text">证书申请</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#团队开发"><span class="nav-number">3.4.2.</span> <span class="nav-text">团队开发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS-证书类型"><span class="nav-number">3.4.3.</span> <span class="nav-text">iOS 证书类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS授权和描述文件"><span class="nav-number">3.4.4.</span> <span class="nav-text">iOS授权和描述文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AdHoc发布和真机调试"><span class="nav-number">3.4.5.</span> <span class="nav-text">AdHoc发布和真机调试</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#iOS代码签名"><span class="nav-number">3.5.</span> <span class="nav-text">iOS代码签名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ipa的组成"><span class="nav-number">3.5.1.</span> <span class="nav-text">ipa的组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关的程序和命令"><span class="nav-number">3.5.2.</span> <span class="nav-text">相关的程序和命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对app重新签名的流程"><span class="nav-number">3.6.</span> <span class="nav-text">对app重新签名的流程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#iOS设备如何验证app是否合法"><span class="nav-number">3.6.1.</span> <span class="nav-text">iOS设备如何验证app是否合法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最简单的前面"><span class="nav-number">4.</span> <span class="nav-text">最简单的前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非APP-Store其他方式"><span class="nav-number">5.</span> <span class="nav-text">非APP Store其他方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充"><span class="nav-number">6.</span> <span class="nav-text">补充</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最终流程"><span class="nav-number">7.</span> <span class="nav-text">最终流程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概念与操作"><span class="nav-number">8.</span> <span class="nav-text">概念与操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它发布方式"><span class="nav-number">9.</span> <span class="nav-text">其它发布方式</span></a></li></ol></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">水煮冰</span></div><div style="text-align:left;width:100%;height:50">Make everything as simple as possible,but not simpler<div></div></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="https://cdn.bootcss.com/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1.1/reading_progress.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script><style>a.gitment-editor-footer-tip{display:none}.gitment-container.gitment-footer-container{display:none}</style><script type="text/javascript">function renderGitment(){var t=new Gitmint({id:window.location.pathname,owner:"StartEnd",repo:"StartEnd.github.io",lang:navigator.language||navigator.systemLanguage||navigator.userLanguage,oauth:{client_secret:"d5a251f817148c7056e3266ebc1f793df84bb0aa",client_id:"707710063f16f73aa47d"}});t.render("gitment-container")}function showGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block",renderGitment()}</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;w<0&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script>!function(t){function e(t,e){var n=new Image,o=t.getAttribute("data-original");n.onload=function(){t.src=o,e&&e()},n.src=o}function n(){for(var n=0;n<o.length;n++)i=o[n],0<=(c=i.getBoundingClientRect()).top&&0<=c.left&&c.top<=(t.innerHeight||document.documentElement.clientHeight)&&e(o[n],function(){o.splice(n,n)});var i,c;console.log("trigger")}var o=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));n(),t.addEventListener("scroll",function(){var e,o;e=n,o=t,clearTimeout(e.tId),e.tId=setTimeout(function(){e.call(o)},500)})}(this)</script></body></html><!-- rebuild by neat -->